---
layout: post
title: "TCP粘包/拆包问题"
description: "Netty TCP粘包/拆包问题"
categories: [io,netty]
tags: [io,netty]
redirect_from:
  - /2019/11/24/
---
# TCP 粘包/拆包问题
### TCP数据传输方式
> TCP传输数据的时候，是以流的方式传递数据的，流就是没有界限的数据，比如河水，是连成一片的，其间没有分界线，TCP是根据缓冲区对数据进行划分，最后分成一个个包，然后进行数据发送，也可能把一个个包的数据封装成一个大的数据包进行发送，这就是粘包/拆包问题。

### TCP粘包/拆包发生的原因
> * 应用程序write写入的字节大小大于套接口发送缓冲区大小。
> * 进行MSS大小的TCP分段
> * 以太帧的payload大于MTU进行IP分片。

### 粘包解决策略
> * 消息定长，每个报文大小为固定长度，不够的空位补空格。
> * 在包尾增加回车换行符进行分割，例如FTP协议。
> * 将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，通常的设计思路为消息头的第一个字段使用int32表示消息总长度。
> * 使用更复杂的应用层协议.

### LineBasedFrameDecoder、StringDecoder原理解析
> LineBasedFrameDecoder的工作原理是他一次便利ButeBuf中的可读字节，判断是否有"\n"或者"\r\n"，如果有，就以此位置为结束位置，它是以换行符为结束标志的解码器，支持接待结束符或者不懈怠结束符两种编码方式，同时支持配置单行的最大长度。如果读取到最大长度后仍然没有返现换行符，就会抛出异常，同时忽略掉之前读取到的异常码流。

> StringDecoder的功能非常简单，他就是将收到的对象转换成字符串，然后继续调用后面的Handler。LineBasedFrameDecoder + StringDecoder 组合就是按行切换的文本编辑器，它被设计用来支持TCP的粘包和拆包。

### 问题
> 如果发送的消息不是以换行符结束的，那怎么办呢？或者没有回车换行符，靠消息头中的长度字段来分包怎么办？

> Netty提供了多种支持TCP粘包/拆包的解码器，用来满足用户的不同诉求。

# 分隔符和定长解码器

> TCP以流的方式进行数据传递，上层的应用协议为了对消息进行区分，采用了以下四种方式：

> * 消息长度固定，累计读取到长度为LEN的报文后，就认为读取到了一个完整的消息；将计数器置位，重新开始读取下一个数据包；
> * 将回车换行符作为消息结束符，例如FTP协议；
> * 将特殊的分隔符作为消息的结束标志，回车换行符就是一种特殊的结束分隔符；
> * 通过消息头中定义长度来表示消息的总长度。  

> Netty 对上面的四种方式做了同意的抽象，提供了四种解码器来解决对应的问题。上面我们说了LineBasedFrameDecoder来解决TCP粘包的问题，下面我们继续说另外两种使用的解码器:DelimiterBasedFrameDecoder和FixedLengthFrameDecoder。
> * DelimiterBasedFrameDecoder：自动完成以分隔符做结束标志的消息解码
> * FixedLengthFrameDecoder：自动完成对定长消息的解码，如果是半包消息，他会缓存半包消息并等待下个包到达后进行拼包，直到读取到一个完整的包。  

> 他们都能解决TCP粘包/拆包导致的读半包问题。

## 说明
> 关于解码器代码，只需在之前demo的initChannel方法中，再添加handler之前，将解码器与StringDecoder加入就可以了，由于代码改动不大，上述不再粘贴代码。下一节我们讲编解码技术。
