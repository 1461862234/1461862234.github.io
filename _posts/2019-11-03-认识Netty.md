---
layout: post
title: "认识Netty"
description: "认识Netty"
categories: [io,netty]
tags: [io,netty]
redirect_from:
  - /2019/11/03/
---
# 认识Netty
  * **为什么不建议使用Java原生NIO编程**
  1. NIO的类库和API复杂，使用麻烦，需要掌握很多额外的插件，如Selector、ServerSocketChannel、SocketChannel、ByteBuffer等
  2. 需要掌握额外的技能做铺垫，如Java多线程编程，因为NIO涉及到Reactor模式，必须熟悉网络编程才能编写出高质量的程序/
  3. 需要处理很多问题，例如客户端重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流处理等问题。
  4. JDK NIO的bug，例如epoll bug，它会导致Selector空轮询，导致CPU100%，虽然官方已经声称修复了该BUG但是事实表明，该BUG一直存在，只是发生频率降低了而已，没有得到根本性的解决。
  参考：https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6403933
  
  * **Netty优点**
  1. API使用简单，开发门槛相对较低
  2. 支持多种主流协议，预置了多种编码解码功能，定制能力强
  3. 性能高，与其他业界主流的NIO框架相比，Netty综合性能最优
  4. 非常成熟、稳定，已经修复了所有已经发现的JKD NIO BUG，不需要在为BUG而烦恼。
  5. 社区活跃，版本更迭周期短，发现的BUG能够被及时修复，同时更多的新功能会加入。
  6. 经历了大规模的商业应用考验，质量可以得到验证。

# Netty开发环境搭建
## Java环境 
> 首先要保证你已经在电脑上安装了Java的开发环境，本问教程安装的JDK版本为1.7，并且配置了JDK的环境变量，安装了IDE，本文使用IDE为eclipse，其余版本IDE请进行对应的配置修改和调整。

## Netty环境
### 下载Netty的软件包
> Netty官网地址：https://netty.io/，在【Downloads】便签页选择下载
【netty-all-5.0.0.Alpha1】，如图：
![netty download](http://139.199.25.193:8099/blog/image/netty/netty-download.png)

> 如果下载不下来也可以去MAVEN中央仓库去下载，网址：https://mvnrepository.com，输入Netty，选择【5.0.0.Alpha1】版本进行下载，如图：
![netty maven download](http://139.199.25.193:8099/blog/image/netty/netty-maven-download.png)

### 搭建Netty应用工程
  > 使用Eclipse 创建普通的Java工程，创建源文件package，创建文件夹lib，并将netty包放入文件夹中，如图：
  ![netty mkdir and package](http://139.199.25.193:8099/blog/image/netty/netty-mkdir.png)

  > 右键点击netty-all-4.1.43.Final.jar，在弹出的菜单中，选择将.jar包加入到Build Path，如图：
  ![netty add jar to build path](http://139.199.25.193:8099/blog/image/netty/netty-add-jar-to-build.png)
  
  > OK到此Netty应用开发环境就已经搭建完成了。

# 基于Netty开发时间服务器程序
## Netty服务端
### Netty时间服务器服务端 TimeServer类
```java
package com.meetleft.netty;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

public class TimeServer {
	
	public void bind(int port) throws Exception{
		// 配置服务端的NIO线程组
		EventLoopGroup bossGroup = new NioEventLoopGroup();
		EventLoopGroup workerGroup = new NioEventLoopGroup();
		try {
			ServerBootstrap b = new ServerBootstrap();
			b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 1024).childHandler(new ChildChannelHandler());
			// 绑定端口，同步等待成功
			ChannelFuture f = b.bind(port).sync();
			// 等待服务端监听端口关闭
			f.channel().closeFuture().sync();
		} catch (Exception e) {
			// TODO: handle exception
		} finally {
			// 释放线程资源
			bossGroup.shutdownGracefully();
			workerGroup.shutdownGracefully();
		}
		
	}
	
	private class ChildChannelHandler extends ChannelInitializer<SocketChannel>{

		@Override
		protected void initChannel(SocketChannel arg0) throws Exception {
			arg0.pipeline().addLast(new TimeServerHandler());
		}
		
	}
	
	public static void main(String[] args) throws Exception {
		int port = 8080;
		if (args != null && args.length > 0) {
			try {
				port = Integer.valueOf(args[0]);
			} catch (Exception e) {
			}
		}
		new TimeServer().bind(port);
	}
}

```
> 首先我们看bind()方法，在bind()方法里面首先创建了两个NioEventLoopGroup实例，NioEventLoopGroup是代表线程组，它包含了一组NIO线程，专门用于网络事件的处理。实际上，NioEventLoopGroup就是Reactor线程组。这里创建两个是因为一个用于接收客户端的连接，另一个用于进行SocketChannel的网络读写。后面创建的ServerBootstrap对象，它是Netty用于NIO的辅助启动类，然后调用它的group方法将两个NIO线程组当参数传入ServerBootStrap中，接着调用channel方法，传入NioServerSocketChannel，将要创建的Channel设置为NioServerSocketChannel，然后设置它的TCP参数，将backlog设置为1024，最后绑定I/O事件处理类ChildChannelHandler，主要作用用来记录日志，对消息进行编码解码等。

> 辅助类设置好之后，调用它的bind方法绑定监听接口，最后调用sync()方法等待绑定操作完成，绑定完成后Netty会返回一个ChannelFuture，主要用于异步操作的通知回调。

> 然后调用ChannelFuture的closeFuture().closeFuture().sync()方法进行阻塞，等待服务端链路关闭后main函数才会推出，最后调用shutdownGracefully()方法释放线程资源。

### Netty 时间服务器服务端 TimeServerHandler
```java
package com.meetleft.netty;


import java.util.Date;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerAdapter;
import io.netty.channel.ChannelHandlerContext;

public class TimeServerHandler  extends ChannelHandlerAdapter{

	@Override
	public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception{
		ByteBuf buf = (ByteBuf) msg;
		byte[] req = new byte[buf.readableBytes()];
		buf.readBytes(req);
		String body = new String(req, "UTF-8");
		System.out.println("The time server receive order : " + body);
		String currentTime = "QUERY TIME ORDER".equalsIgnoreCase(body)?new Date(System.currentTimeMillis()).toString():"BAD ORDER";
		ByteBuf resp = Unpooled.copiedBuffer(currentTime.getBytes());
		ctx.write(resp);
	}

	@Override
	public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
		ctx.flush();
	}

	@Override
	public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
		ctx.close();
	}
	
}
```

> TimeServerHandler 继承ChannelHandlerAdapter，主要对网络事件进行读写，通常我们只需要关注channelRead与exceptionCaught两个方法就行了。

> 首先在channelRead方法中将msg的类型转换，转换为ByteBuf对象，ByteBuf类似于java.nio.ButeBuffer对象，通过ButeBuf的readableBytes方法，可以获取缓冲区可读的字节数，可以根据字节数创建byte数组，而ByteBuf的readBytes方法，可以将缓冲区中的字节数组复制到新的byte数组中，最后通过String类的构造函数来获取请求数据，最后对数据进行判断返回相应的时间或者其他信息。

> 在channelReadComplete 方法中，我们发现调用了flush方法，它的作用是将消息队列中的消息写入到SocketChannel中发给对方。在Netty中write只是把数据写入到缓冲区中，而不是直接写道SocketChannel中，是调用flush方法将缓冲区中的消息全部写到SocketChannel中。

> exceptionCaught方法是Netty的异常机制，当异常发生时，他会调用close方法释放ChannelHandlerContext相关联的句柄等资源。
